Text::Data Structure and Algorithms (DSA) Tutorial, URL->https://www.tutorialspoint.com/data_structures_algorithms/
 Data Structures are the programmatic way of storing data so that data can be used efficiently. Almost every enterprise application uses various types of data structures in one or the other way. This tutorial will give you a great understanding on Data Structures needed to understand the complexity of enterprise level applications and need of algorithms, and data structures. This tutorial is designed for Computer Science graduates as well as Software Professionals who are willing to learn data structures and algorithm programming in simple and easy steps. After completing this tutorial you will be at intermediate level of expertise from where you can take yourself to higher level of expertise. Before proceeding with this tutorial, you should have a basic understanding of C programming language, text editor, and execution of programs, etc. For most of the examples given in this tutorial you will find Try it option, so just make use of this option to execute your programs on the spot and enjoy your learning. Try the following example using the Try it option available at the top right corner of the following sample code box − © Copyright 2017. All Rights Reserved.
---------------------------------------------------------------------------------------------------
Text::Data Structures Algorithms Basics - TutorialsPoint, URL->https://www.tutorialspoint.com/data_structures_algorithms/algorithms_basics.htm
 Algorithm is a step-by-step procedure, which defines a set of instructions to be executed in a certain order to get the desired output. Algorithms are generally created independent of underlying languages, i.e. an algorithm can be implemented in more than one programming language. From the data structure point of view, following are some important categories of algorithms − Search − Algorithm to search an item in a data structure. Sort − Algorithm to sort items in a certain order. Insert − Algorithm to insert item in a data structure. Update − Algorithm to update an existing item in a data structure. Delete − Algorithm to delete an existing item from a data structure. Not all procedures can be called an algorithm. An algorithm should have the following characteristics − Unambiguous − Algorithm should be clear and unambiguous. Each of its steps (or phases), and their inputs/outputs should be clear and must lead to only one meaning. Input − An algorithm should have 0 or more well-defined inputs. Output − An algorithm should have 1 or more well-defined outputs, and should match the desired output. Finiteness − Algorithms must terminate after a finite number of steps. Feasibility − Should be feasible with the available resources. Independent − An algorithm should have step-by-step directions, which should be independent of any programming code. There are no well-defined standards for writing algorithms. Rather, it is problem and resource dependent. Algorithms are never written to support a particular programming code. As we know that all programming languages share basic code constructs like loops (do, for, while), flow-control (if-else), etc. These common constructs can be used to write an algorithm. We write algorithms in a step-by-step manner, but it is not always the case. Algorithm writing is a process and is executed after the problem domain is well-defined. That is, we should know the problem domain, for which we are designing a solution. Let's try to learn algorithm-writing by using an example. Problem − Design an algorithm to add two numbers and display the result. Algorithms tell the programmers how to code the program. Alternatively, the algorithm can be written as − In design and analysis of algorithms, usually the second method is used to describe an algorithm. It makes it easy for the analyst to analyze the algorithm ignoring all unwanted definitions. He can observe what operations are being used and how the process is flowing. Writing step numbers, is optional. We design an algorithm to get a solution of a given problem. A problem can be solved in more than one ways. Hence, many solution algorithms can be derived for a given problem. The next step is to analyze those proposed solution algorithms and implement the best suitable solution. Efficiency of an algorithm can be analyzed at two different stages, before implementation and after implementation. They are the following − A Priori Analysis − This is a theoretical analysis of an algorithm. Efficiency of an algorithm is measured by assuming that all other factors, for example, processor speed, are constant and have no effect on the implementation. A Posterior Analysis − This is an empirical analysis of an algorithm. The selected algorithm is implemented using programming language. This is then executed on target computer machine. In this analysis, actual statistics like running time and space required, are collected. We shall learn about a priori algorithm analysis. Algorithm analysis deals with the execution or running time of various operations involved. The running time of an operation can be defined as the number of computer instructions executed per operation. Suppose X is an algorithm and n is the size of input data, the time and space used by the algorithm X are the two main factors, which decide the efficiency of X. Time Factor − Time is measured by counting the number of key operations such as comparisons in the sorting algorithm. Space Factor − Space is measured by counting the maximum memory space required by the algorithm. The complexity of an algorithm f(n) gives the running time and/or the storage space required by the algorithm in terms of n as the size of input data. Space complexity of an algorithm represents the amount of memory space required by the algorithm in its life cycle. The space required by an algorithm is equal to the sum of the following two components − A fixed part that is a space required to store certain data and variables, that are independent of the size of the problem. For example, simple variables and constants used, program size, etc. A variable part is a space required by variables, whose size depends on the size of the problem. For example, dynamic memory allocation, recursion stack space, etc. Space complexity S(P) of any algorithm P is S(P) = C + SP(I), where C is the fixed part and S(I) is the variable part of the algorithm, which depends on instance characteristic I. Following is a simple example that tries to explain the concept − Here we have three variables A, B, and C and one constant. Hence S(P) = 1 + 3. Now, space depends on data types of given variables and constant types and it will be multiplied accordingly. Time complexity of an algorithm represents the amount of time required by the algorithm to run to completion. Time requirements can be defined as a numerical function T(n), where T(n) can be measured as the number of steps, provided each step consumes constant time. For example, addition of two n-bit integers takes n steps. Consequently, the total computational time is T(n) = c ∗ n, where c is the time taken for the addition of two bits. Here, we observe that T(n) grows linearly as the input size increases. © Copyright 2017. All Rights Reserved.
---------------------------------------------------------------------------------------------------
Text::Data Structures and Algorithms Specialization - Coursera, URL->https://www.coursera.org/specializations/data-structures-algorithms
 Financial Aid is available for learners who cannot afford the fee. Learn more and apply. Created by: Industry Partners: Follow the suggested order or choose your own. Designed to help you practice and apply the skills you learn. Highlight your new skills on your resume or LinkedIn. UC San Diego is an academic powerhouse and economic engine, recognized as one of the top 10 public universities by U.S. News and World Report. Faculty at the Computer Science and Engineering Department at UCSD are among the leaders in the field of algorithms, bioinformatics, cryptography, machine learning, and many other areas of computer science. UC San Diego is an academic powerhouse and economic engine, recognized as one of the top 10 public universities by U.S. News and World Report. Innovation is central to who we are and what we do. Here, students learn that knowledge isn't just acquired in the classroom—life is their laboratory. Faculty of Computer Science (http://cs.hse.ru/en/) trains developers and researchers. The programme has been created based on the experience of leading American and European universities, such as Stanford University (U.S.) and EPFL (Switzerland). Also taken into consideration when creating the faculty was the School of Data Analysis, which is one of the strongest postgraduate schools in the field of computer science in Russia. In the faculty, learning is based on practice and projects. National Research University - Higher School of Economics (HSE) is one of the top research universities in Russia. Established in 1992 to promote new research and teaching in economics and related disciplines, it now offers programs at all levels of university education across an extraordinary range of fields of study including business, sociology, cultural studies, philosophy, political science, international relations, law, Asian studies, media and communications, IT, mathematics, engineering, and more. Learn more on www.hse.ru What is the Capstone Project? What is the refund policy? Can I just enroll in a single course? I'm not interested in the entire Specialization. Is financial aid available? What will I be able to do upon completing the Specialization? What background knowledge is necessary? What is the difference between this course and other courses covering algorithms? How long does it take to complete the Specialization? How often is each course in the Specialization offered? What background knowledge is necessary? Do I need to take the courses in a specific order? Will I earn university credit for completing the Specialization? Do I need to buy a textbook for this specialization? Coursera Coursera provides universal access to the world’s best education, partnering with top universities and organizations to offer courses online. 
---------------------------------------------------------------------------------------------------
Text::Learn Data Structures and Algorithms - Best Data Structures and ..., URL->https://hackr.io/tutorials/learn-data-structures-algorithms
 Welcome back! If you find any tutorial useful, don't forgot to vote it up. Upvote on useful tutorials helps the community. Hackr.io is a site for programmers to find and share the best online programming courses & tutorials. Join them, it only takes 30 seconds. Here's how it works: Anybody can submit a course/tutorial Community upvotes the beneficial tutorials The best tutorial rise to the top What rule does this break? What rule does this break? What rule does this break? What rule does this break? What rule does this break? What rule does this break? What rule does this break? What rule does this break? What rule does this break? What rule does this break? What rule does this break? What rule does this break? What rule does this break? What rule does this break? What rule does this break? What rule does this break? Don't have an account? Sign Up. Already have an account? Sign In.
---------------------------------------------------------------------------------------------------
Text::Data Structures and Algorithms: Table of Contents, URL->https://www.cs.auckland.ac.nz/~jmor159/PLDS210/ds_ToC.html
 Front Page Course Outline © John Morris, 1998
---------------------------------------------------------------------------------------------------
